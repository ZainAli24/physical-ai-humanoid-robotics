"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_01=globalThis.webpackChunkphysical_ai_humanoid_robotics_01||[]).push([[898],{6704:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-2-gazebo/simulation-best-practices","title":"Simulation Best Practices","description":"Learn best practices for robot simulation testing, performance optimization, and troubleshooting common issues","source":"@site/docs/module-2-gazebo/simulation-best-practices.md","sourceDirName":"module-2-gazebo","slug":"/module-2-gazebo/simulation-best-practices","permalink":"/physical-ai-humanoid-robotics/docs/module-2-gazebo/simulation-best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-gazebo/simulation-best-practices.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Simulation Best Practices","description":"Learn best practices for robot simulation testing, performance optimization, and troubleshooting common issues"},"sidebar":"mainSidebar","previous":{"title":"Unity for Robotics","permalink":"/physical-ai-humanoid-robotics/docs/module-2-gazebo/unity-robotics"},"next":{"title":"Introduction to NVIDIA Isaac","permalink":"/physical-ai-humanoid-robotics/docs/module-3-isaac/intro-isaac"}}');var t=n(4848),r=n(8453);const o={sidebar_position:3,title:"Simulation Best Practices",description:"Learn best practices for robot simulation testing, performance optimization, and troubleshooting common issues"},l="Simulation Best Practices",a={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Simulation Testing Workflow",id:"simulation-testing-workflow",level:2},{value:"Testing Pyramid for Robotics",id:"testing-pyramid-for-robotics",level:3},{value:"1. Unit Tests (Fastest, Most Numerous)",id:"1-unit-tests-fastest-most-numerous",level:3},{value:"2. Integration Tests (Moderate Complexity)",id:"2-integration-tests-moderate-complexity",level:3},{value:"3. Simulation Tests (Full System, Realistic Environment)",id:"3-simulation-tests-full-system-realistic-environment",level:3},{value:"4. Real Robot Tests (Ground Truth)",id:"4-real-robot-tests-ground-truth",level:3},{value:"Choosing the Right Simulator",id:"choosing-the-right-simulator",level:2},{value:"Simulator Comparison Matrix",id:"simulator-comparison-matrix",level:3},{value:"Decision Flowchart",id:"decision-flowchart",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"1. Physics Timestep Tuning",id:"1-physics-timestep-tuning",level:3},{value:"2. Rendering Optimization",id:"2-rendering-optimization",level:3},{value:"3. Parallel Simulations",id:"3-parallel-simulations",level:3},{value:"4. Sensor Update Rate Tuning",id:"4-sensor-update-rate-tuning",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Issue 1: Physics Instability (Robot Vibrates or Explodes)",id:"issue-1-physics-instability-robot-vibrates-or-explodes",level:3},{value:"Issue 2: Sensor Noise Too Low (Unrealistic Performance)",id:"issue-2-sensor-noise-too-low-unrealistic-performance",level:3},{value:"Issue 3: ROS 2 Bridge Failures (Topics Not Publishing)",id:"issue-3-ros-2-bridge-failures-topics-not-publishing",level:3},{value:"Issue 4: Slow Real-Time Factor (RTF &lt; 0.5)",id:"issue-4-slow-real-time-factor-rtf--05",level:3},{value:"Example: Simulation Testing Script",id:"example-simulation-testing-script",level:2},{value:"Hands-On Exercises",id:"hands-on-exercises",level:2},{value:"Exercise 1: Write a Simulation Unit Test",id:"exercise-1-write-a-simulation-unit-test",level:3},{value:"Exercise 2: Optimize Physics Performance",id:"exercise-2-optimize-physics-performance",level:3},{value:"Exercise 3: Debug Collision Issues",id:"exercise-3-debug-collision-issues",level:3},{value:"Exercise 4: Measure Performance Metrics",id:"exercise-4-measure-performance-metrics",level:3},{value:"Exercise 5: Validate Sensor Data",id:"exercise-5-validate-sensor-data",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Navigation",id:"navigation",level:2}];function d(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"simulation-best-practices",children:"Simulation Best Practices"})}),"\n",(0,t.jsx)(s.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsx)(s.p,{children:"Before starting this chapter, you should have:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"\u2705 Completed Chapter 1: Introduction to Gazebo"}),"\n",(0,t.jsx)(s.li,{children:"\u2705 Completed Chapter 2: Unity for Robotics"}),"\n",(0,t.jsx)(s.li,{children:"\u2705 Understanding of Gazebo Garden and Unity 2022 LTS fundamentals"}),"\n",(0,t.jsx)(s.li,{children:"\u2705 Experience launching simulations and loading robot models"}),"\n",(0,t.jsx)(s.li,{children:"\u2705 Basic understanding of ROS 2 topics, launch files, and Python programming"}),"\n",(0,t.jsx)(s.li,{children:"\u2705 Familiarity with robot testing concepts (unit tests, integration tests)"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Estimated Reading Time"}),": 20-25 minutes"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(s.p,{children:["Simulation is a powerful tool for robotics development, but it's not a perfect replacement for real-world testing. ",(0,t.jsx)(s.strong,{children:"The simulation-to-reality gap"})," (often called the ",(0,t.jsx)(s.strong,{children:"sim-to-real gap"}),") refers to the differences between simulated behavior and real-world performance. Factors like sensor noise, physics approximations, timing variations, and environmental complexity can cause algorithms that work perfectly in simulation to fail on real robots."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Importance of Simulation Testing"}),": Despite the sim-to-real gap, simulation remains essential for:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Rapid Prototyping"}),": Test hundreds of scenarios in the time it takes to run one real-world experiment"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Safety"}),": Validate risky behaviors (collision recovery, emergency stops) without endangering people or equipment"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reproducibility"}),": Run identical test conditions multiple times to isolate bugs and measure performance"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Cost-Effectiveness"}),": Reduce hardware wear-and-tear and development costs during early-stage testing"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Chapter Goals"}),": By the end of this chapter, you will understand how to design effective simulation testing workflows, choose between Gazebo and Unity based on your needs, optimize simulation performance, and troubleshoot common simulation issues. You'll learn strategies to minimize the sim-to-real gap and validate that your algorithms are robust enough for physical deployment."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Learning Objectives"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"Design a simulation testing workflow that progresses from unit tests to integration tests to real-world deployment"}),"\n",(0,t.jsx)(s.li,{children:"Understand the sim-to-real gap and strategies to mitigate it (domain randomization, realistic sensor models, system identification)"}),"\n",(0,t.jsx)(s.li,{children:"Choose the appropriate simulator (Gazebo vs Unity vs Isaac) based on project requirements"}),"\n",(0,t.jsx)(s.li,{children:"Optimize simulation performance (physics timestep tuning, rendering settings, parallel simulations)"}),"\n",(0,t.jsx)(s.li,{children:"Troubleshoot common simulation issues (physics instability, sensor noise, model collisions, slow real-time factor)"}),"\n",(0,t.jsx)(s.li,{children:"Validate simulation results against real-world data to build confidence in your algorithms"}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"simulation-testing-workflow",children:"Simulation Testing Workflow"}),"\n",(0,t.jsxs)(s.p,{children:["A robust simulation testing workflow follows a ",(0,t.jsx)(s.strong,{children:"progressive validation strategy"}),": start with simple, fast tests and gradually increase complexity until you're confident enough to deploy to real hardware."]}),"\n",(0,t.jsx)(s.h3,{id:"testing-pyramid-for-robotics",children:"Testing Pyramid for Robotics"}),"\n",(0,t.jsx)(s.p,{children:"The testing pyramid is a software engineering concept adapted for robotics:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-mermaid",children:"graph TD\n    A[Unit Tests<br/>Fast, Isolated, Many] --\x3e B[Integration Tests<br/>Moderate Speed, Combined Components]\n    B --\x3e C[Simulation Tests<br/>Slow, Full System, Realistic]\n    C --\x3e D[Real Robot Tests<br/>Slowest, Expensive, Ground Truth]\n\n    style A fill:#4CAF50,stroke:#2E7D32,color:#fff\n    style B fill:#FFC107,stroke:#F57C00,color:#000\n    style C fill:#FF9800,stroke:#E65100,color:#fff\n    style D fill:#F44336,stroke:#C62828,color:#fff\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.em,{children:"Figure 1: Testing pyramid showing the progression from fast unit tests (many) to slow real robot tests (few). Each layer builds confidence before moving to the next."})}),"\n",(0,t.jsx)(s.h3,{id:"1-unit-tests-fastest-most-numerous",children:"1. Unit Tests (Fastest, Most Numerous)"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Purpose"}),": Test individual components in isolation (perception algorithms, planners, controllers) without full simulation."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Tools"}),": Python ",(0,t.jsx)(s.code,{children:"unittest"}),", ",(0,t.jsx)(s.code,{children:"pytest"}),", ROS 2 ",(0,t.jsx)(s.code,{children:"launch_testing"})]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Example"}),": Test a path planning algorithm with synthetic obstacle data:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"import unittest\nimport numpy as np\nfrom my_robot_pkg.path_planner import AStarPlanner\n\nclass TestAStarPlanner(unittest.TestCase):\n    def setUp(self):\n        self.planner = AStarPlanner(grid_size=(100, 100))\n\n    def test_finds_path_in_empty_space(self):\n        start = (10, 10)\n        goal = (90, 90)\n        path = self.planner.plan(start, goal, obstacles=[])\n\n        self.assertIsNotNone(path)\n        self.assertEqual(path[0], start)\n        self.assertEqual(path[-1], goal)\n\n    def test_avoids_obstacles(self):\n        start = (10, 10)\n        goal = (90, 90)\n        obstacles = [(50, 50), (51, 50), (52, 50)]  # Wall blocking direct path\n\n        path = self.planner.plan(start, goal, obstacles)\n\n        self.assertIsNotNone(path)\n        for obstacle in obstacles:\n            self.assertNotIn(obstacle, path)  # Path should not pass through obstacles\n\nif __name__ == '__main__':\n    unittest.main()\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Benefits"}),": Unit tests run in milliseconds, enable rapid iteration, and catch logic errors before expensive simulation tests."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"2-integration-tests-moderate-complexity",children:"2. Integration Tests (Moderate Complexity)"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Purpose"}),": Test multiple components working together (e.g., perception + planning, localization + navigation) with realistic ROS 2 message flows."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Tools"}),": ROS 2 ",(0,t.jsx)(s.code,{children:"launch_testing"}),", simulated sensor data playback (rosbag), mock ROS 2 nodes"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Example"}),": Test that your navigation stack responds correctly to obstacle detection:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"import launch_testing\nimport rclpy\nfrom geometry_msgs.msg import Twist\nfrom sensor_msgs.msg import LaserScan\n\ndef test_navigation_stops_on_obstacle():\n    # Launch navigation stack\n    # ...\n\n    # Publish fake laser scan showing obstacle ahead\n    fake_scan = LaserScan()\n    fake_scan.ranges = [1.0] * 360  # All ranges at 1 meter (obstacle ahead)\n    laser_pub.publish(fake_scan)\n\n    # Check that /cmd_vel is zero (robot should stop)\n    cmd_vel_msg = wait_for_message('/cmd_vel', Twist, timeout=5.0)\n    assert cmd_vel_msg.linear.x == 0.0, \"Robot should stop when obstacle detected\"\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Benefits"}),": Integration tests validate component interactions without the overhead of full physics simulation."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"3-simulation-tests-full-system-realistic-environment",children:"3. Simulation Tests (Full System, Realistic Environment)"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Purpose"}),": Test the complete robotic system (perception, planning, control) in a simulated environment with physics and sensors."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Tools"}),": Gazebo, Unity, Isaac Sim"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Example Workflow"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"Launch Gazebo with a test world (e.g., office environment with obstacles)"}),"\n",(0,t.jsx)(s.li,{children:"Spawn robot with sensors (camera, LiDAR, IMU)"}),"\n",(0,t.jsx)(s.li,{children:"Start navigation stack, give goal pose"}),"\n",(0,t.jsx)(s.li,{children:"Monitor for successful navigation to goal within timeout"}),"\n",(0,t.jsx)(s.li,{children:"Log metrics (time to goal, path smoothness, collision count)"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Example Launch Test for Simulation"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from launch import LaunchDescription\nfrom launch.actions import IncludeLaunchDescription, TimerAction\nfrom launch_ros.actions import Node\nimport launch_testing.actions\n\ndef generate_test_description():\n    # Launch Gazebo with test world\n    gazebo = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource([\n            os.path.join(get_package_share_directory('ros_gz_sim'), 'launch', 'gz_sim.launch.py')\n        ]),\n        launch_arguments={'gz_args': 'office_world.sdf'}.items()\n    )\n\n    # Spawn robot\n    spawn_robot = Node(\n        package='ros_gz_sim',\n        executable='create',\n        arguments=['-name', 'test_robot', '-file', 'test_robot.urdf']\n    )\n\n    # Wait 5 seconds for simulation to stabilize, then run test\n    test_node = TimerAction(\n        period=5.0,\n        actions=[Node(package='my_robot_test', executable='navigation_test')]\n    )\n\n    return LaunchDescription([\n        gazebo,\n        spawn_robot,\n        test_node,\n        launch_testing.actions.ReadyToTest()\n    ])\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Benefits"}),": Simulation tests validate full-system behavior with realistic sensor noise, physics interactions, and timing constraints."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"4-real-robot-tests-ground-truth",children:"4. Real Robot Tests (Ground Truth)"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Purpose"}),": Final validation on physical hardware to measure the sim-to-real gap and ensure deployment readiness."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Best Practices"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Start with controlled environments (lab, marked testing area)"}),"\n",(0,t.jsx)(s.li,{children:"Gradually increase complexity (dynamic obstacles, outdoor environments, human interactions)"}),"\n",(0,t.jsx)(s.li,{children:"Log all data (sensor readings, commands, trajectories) for post-test analysis"}),"\n",(0,t.jsx)(s.li,{children:"Compare real-world performance metrics to simulation baselines"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Sim-to-Real Gap Analysis"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Measure discrepancies"}),": If simulation predicts 90% navigation success but real robot achieves 70%, investigate causes (sensor noise, calibration, unexpected dynamics)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Iterate on simulation"}),": Add noise models, update physics parameters, improve world models to make simulation more realistic"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Set conservative thresholds"}),": If your simulation success rate is 95%, aim for 98%+ before deploying to real hardware (to account for the gap)"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"choosing-the-right-simulator",children:"Choosing the Right Simulator"}),"\n",(0,t.jsx)(s.p,{children:"Different simulators have different strengths. Here's a decision matrix to guide your choice:"}),"\n",(0,t.jsx)(s.h3,{id:"simulator-comparison-matrix",children:"Simulator Comparison Matrix"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:(0,t.jsx)(s.strong,{children:"Criterion"})}),(0,t.jsx)(s.th,{children:(0,t.jsx)(s.strong,{children:"Gazebo Garden"})}),(0,t.jsx)(s.th,{children:(0,t.jsx)(s.strong,{children:"Unity 2022 LTS"})}),(0,t.jsx)(s.th,{children:(0,t.jsx)(s.strong,{children:"NVIDIA Isaac Sim"})})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Physics Fidelity"})}),(0,t.jsx)(s.td,{children:"High (ODE, DART, Bullet)"}),(0,t.jsx)(s.td,{children:"Medium (PhysX, Unity Physics)"}),(0,t.jsx)(s.td,{children:"Very High (PhysX 5 GPU)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Rendering Quality"})}),(0,t.jsx)(s.td,{children:"Functional"}),(0,t.jsx)(s.td,{children:"Photorealistic (URP/HDRP)"}),(0,t.jsx)(s.td,{children:"Photorealistic (RTX ray-tracing)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"ROS 2 Integration"})}),(0,t.jsx)(s.td,{children:"Native (DDS-based)"}),(0,t.jsx)(s.td,{children:"TCP Bridge (adds latency)"}),(0,t.jsx)(s.td,{children:"OmniGraph + ROS 2 bridge"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"RL Training Support"})}),(0,t.jsx)(s.td,{children:"Limited"}),(0,t.jsx)(s.td,{children:"Limited"}),(0,t.jsx)(s.td,{children:"Excellent (Isaac Gym parallel envs)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"VR/AR Support"})}),(0,t.jsx)(s.td,{children:"No"}),(0,t.jsx)(s.td,{children:"Native (Quest, HoloLens)"}),(0,t.jsx)(s.td,{children:"Experimental"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"GPU Acceleration"})}),(0,t.jsx)(s.td,{children:"Rendering only"}),(0,t.jsx)(s.td,{children:"Rendering + limited physics"}),(0,t.jsx)(s.td,{children:"Full physics + rendering"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Sensor Simulation"})}),(0,t.jsx)(s.td,{children:"Excellent (cameras, LiDAR, IMU, GPS)"}),(0,t.jsx)(s.td,{children:"Good (cameras, basic sensors)"}),(0,t.jsx)(s.td,{children:"Excellent (RGB, depth, semantic, LiDAR)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Multi-Robot Scaling"})}),(0,t.jsx)(s.td,{children:"Good (dozens of robots)"}),(0,t.jsx)(s.td,{children:"Good (depends on hardware)"}),(0,t.jsx)(s.td,{children:"Excellent (thousands of parallel envs)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Open Source"})}),(0,t.jsx)(s.td,{children:"Yes (Apache 2.0)"}),(0,t.jsx)(s.td,{children:"Engine is proprietary"}),(0,t.jsx)(s.td,{children:"Proprietary (free for research)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Learning Curve"})}),(0,t.jsx)(s.td,{children:"Steep (XML-based config)"}),(0,t.jsx)(s.td,{children:"Moderate (visual editor)"}),(0,t.jsx)(s.td,{children:"Steep (USD format, Python API)"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.strong,{children:"Best For"})}),(0,t.jsx)(s.td,{children:"Control validation, sensor testing, traditional robotics"}),(0,t.jsx)(s.td,{children:"HRI, teleoperation UIs, demos, CV datasets"}),(0,t.jsx)(s.td,{children:"RL training, large-scale sim, synthetic data"})]})]})]}),"\n",(0,t.jsx)(s.h3,{id:"decision-flowchart",children:"Decision Flowchart"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-mermaid",children:"flowchart TD\n    Start[Choose Simulator] --\x3e Q1{Primary Goal?}\n\n    Q1 --\x3e|Physics Testing<br/>Control Validation| Gazebo[Use Gazebo Garden]\n    Q1 --\x3e|Visualization<br/>User Interfaces| Q2{VR/AR Required?}\n    Q1 --\x3e|RL Training| Q3{GPU Available?}\n    Q1 --\x3e|Synthetic Data<br/>for CV| Q4{Budget?}\n\n    Q2 --\x3e|Yes| Unity[Use Unity 2022 LTS]\n    Q2 --\x3e|No| Unity\n\n    Q3 --\x3e|Yes, NVIDIA RTX| Isaac[Use NVIDIA Isaac Sim]\n    Q3 --\x3e|No| Gazebo\n\n    Q4 --\x3e|Budget for GPU| Isaac\n    Q4 --\x3e|Limited Budget| Unity\n\n    Gazebo --\x3e|Secondary Viz| Unity2[+ Unity for Teleoperation UI]\n    Unity --\x3e|Secondary Physics| Gazebo2[+ Gazebo for Physics Validation]\n    Isaac --\x3e|Secondary Dev| Gazebo3[+ Gazebo for Quick Prototyping]\n\n    style Gazebo fill:#4CAF50,stroke:#2E7D32,color:#fff\n    style Unity fill:#2196F3,stroke:#1565C0,color:#fff\n    style Isaac fill:#FF9800,stroke:#E65100,color:#fff\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.em,{children:"Figure 2: Decision flowchart for selecting the appropriate simulator based on project requirements. Many teams use multiple simulators for different purposes."})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Hybrid Approach"}),": Many advanced robotics teams use ",(0,t.jsx)(s.strong,{children:"multiple simulators"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Gazebo"})," for physics validation and sensor testing"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Unity"})," for teleoperation interfaces and public demonstrations"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Isaac Sim"})," for reinforcement learning training and large-scale data generation"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(s.p,{children:"Slow simulation can bottleneck development. Here are strategies to optimize simulation performance:"}),"\n",(0,t.jsx)(s.h3,{id:"1-physics-timestep-tuning",children:"1. Physics Timestep Tuning"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Problem"}),": Default physics timesteps may be too small (accurate but slow) or too large (fast but unstable)."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Solution"}),": Adjust the physics update rate in your world file:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-xml",children:'\x3c!-- In your Gazebo SDF world file --\x3e\n<world name="default">\n  <physics name="default_physics" type="ode">\n    <max_step_size>0.001</max_step_size>  \x3c!-- 1ms timestep (1000 Hz) --\x3e\n    <real_time_factor>1.0</real_time_factor>\n    <real_time_update_rate>1000</real_time_update_rate>\n  </physics>\n</world>\n'})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Optimization"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Increase timestep"})," for faster simulation: ",(0,t.jsx)(s.code,{children:"0.005"})," (5ms, 200 Hz) - acceptable for wheeled robots"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Decrease timestep"})," for stability: ",(0,t.jsx)(s.code,{children:"0.0005"})," (0.5ms, 2000 Hz) - needed for fast manipulators or legged robots"]}),"\n",(0,t.jsxs)(s.li,{children:["Monitor ",(0,t.jsx)(s.strong,{children:"Real-Time Factor (RTF)"})," in Gazebo GUI: RTF < 1.0 means simulation is slower than real-time"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"2-rendering-optimization",children:"2. Rendering Optimization"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Problem"}),": Rendering high-fidelity graphics can slow simulation even if physics is fast."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Solution"}),": Run Gazebo in headless mode (no GUI) for automated tests:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"gz sim -s world.sdf  # -s flag = server mode (no rendering)\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Unity Optimization"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Reduce camera resolution: 640x480 instead of 1920x1080"}),"\n",(0,t.jsx)(s.li,{children:"Disable post-processing effects (bloom, depth of field, anti-aliasing)"}),"\n",(0,t.jsxs)(s.li,{children:["Use Unity's ",(0,t.jsx)(s.strong,{children:"Low Quality"})," preset for physics testing"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"3-parallel-simulations",children:"3. Parallel Simulations"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Problem"}),": Running one simulation at a time is slow for hyperparameter tuning or Monte Carlo testing."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Solution"}),": Launch multiple Gazebo instances with different parameters:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'# Example: Run 10 parallel simulations with different PID gains\nimport subprocess\n\nfor kp in [1.0, 2.0, 3.0, ..., 10.0]:\n    cmd = f"gz sim -s world.sdf --ros-args -p kp:={kp}"\n    subprocess.Popen(cmd.split(), env={...})\n'})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"NVIDIA Isaac Sim"}),": Natively supports thousands of parallel environments on a single GPU for reinforcement learning."]}),"\n",(0,t.jsx)(s.h3,{id:"4-sensor-update-rate-tuning",children:"4. Sensor Update Rate Tuning"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Problem"}),": Sensors updating too fast (e.g., camera at 60 Hz) can overwhelm CPU."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Solution"}),": Reduce sensor update rates to match real hardware:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-xml",children:'\x3c!-- In Gazebo SDF model file --\x3e\n<sensor name="camera" type="camera">\n  <update_rate>30</update_rate>  \x3c!-- 30 Hz instead of default 60 Hz --\x3e\n  <camera>\n    <image>\n      <width>640</width>  \x3c!-- Reduce resolution if not needed --\x3e\n      <height>480</height>\n    </image>\n  </camera>\n</sensor>\n'})}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,t.jsx)(s.h3,{id:"issue-1-physics-instability-robot-vibrates-or-explodes",children:"Issue 1: Physics Instability (Robot Vibrates or Explodes)"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Symptoms"}),": Robot model shakes violently, falls through the ground, or parts separate unexpectedly."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Causes"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Collision geometries overlap (e.g., wheel inside chassis)"}),"\n",(0,t.jsx)(s.li,{children:"Inertia values too small or incorrect"}),"\n",(0,t.jsx)(s.li,{children:"Joint limits not set properly"}),"\n",(0,t.jsx)(s.li,{children:"Timestep too large for the system dynamics"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Solutions"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Check collision geometries"}),': Open model in Gazebo, enable "View \u2192 Collisions" to visualize collision shapes']}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Increase inertia"}),": Add realistic inertia values to links (use MeshLab or SolidWorks to compute from CAD models)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Reduce timestep"}),": Set ",(0,t.jsx)(s.code,{children:"<max_step_size>0.0005</max_step_size>"})," for more stable physics"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Add damping"}),": Increase joint damping to reduce oscillations:","\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-xml",children:'<joint name="wheel_joint" type="continuous">\n  <dynamics>\n    <damping>0.1</damping>\n  </dynamics>\n</joint>\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"issue-2-sensor-noise-too-low-unrealistic-performance",children:"Issue 2: Sensor Noise Too Low (Unrealistic Performance)"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Symptoms"}),": Algorithms work perfectly in simulation but fail in real world due to sensor noise."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Causes"}),": Default Gazebo sensors have no noise (perfect measurements)."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Solutions"}),": Add realistic noise models to sensors:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-xml",children:'<sensor name="camera" type="camera">\n  <camera>\n    <noise>\n      <type>gaussian</type>\n      <mean>0.0</mean>\n      <stddev>0.007</stddev>  \x3c!-- Add Gaussian noise (based on real sensor specs) --\x3e\n    </noise>\n  </camera>\n</sensor>\n\n<sensor name="imu" type="imu">\n  <imu>\n    <angular_velocity>\n      <x><noise type="gaussian"><mean>0.0</mean><stddev>0.00018</stddev></noise></x>\n      <y><noise type="gaussian"><mean>0.0</mean><stddev>0.00018</stddev></noise></y>\n      <z><noise type="gaussian"><mean>0.0</mean><stddev>0.00018</stddev></noise></z>\n    </angular_velocity>\n  </imu>\n</sensor>\n'})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Reference"}),": Use real sensor datasheets to determine realistic noise parameters (e.g., IMU gyroscope noise density)."]}),"\n",(0,t.jsx)(s.h3,{id:"issue-3-ros-2-bridge-failures-topics-not-publishing",children:"Issue 3: ROS 2 Bridge Failures (Topics Not Publishing)"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Symptoms"}),": Gazebo is running but ROS 2 topics are not receiving data."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Causes"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"ros_gz_bridge"})," not started"]}),"\n",(0,t.jsx)(s.li,{children:"Topic names mismatch between Gazebo and ROS 2"}),"\n",(0,t.jsx)(s.li,{children:"Message type incompatibility"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Solutions"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Verify bridge is running"}),":","\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"ros2 node list | grep ros_gz_bridge\n"})}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Check topic mappings"}),": List Gazebo topics and ROS 2 topics side-by-side:","\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"gz topic -l           # Gazebo topics\nros2 topic list       # ROS 2 topics\n"})}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Manually configure bridge"}),": Create a YAML config file for explicit topic mapping:","\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-yaml",children:'# bridge_config.yaml\n- topic_name: "/camera/image_raw"\n  ros_type_name: "sensor_msgs/msg/Image"\n  gz_type_name: "ignition.msgs.Image"\n  direction: GZ_TO_ROS\n'})}),"\n","Launch with:","\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"ros2 run ros_gz_bridge parameter_bridge --ros-args -p config_file:=bridge_config.yaml\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"issue-4-slow-real-time-factor-rtf--05",children:"Issue 4: Slow Real-Time Factor (RTF < 0.5)"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Symptoms"}),": Simulation runs much slower than real-time, making testing tedious."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Causes"}),":"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Physics timestep too small"}),"\n",(0,t.jsx)(s.li,{children:"Too many collision checks (complex geometries)"}),"\n",(0,t.jsx)(s.li,{children:"GPU rendering overhead"}),"\n",(0,t.jsx)(s.li,{children:"Insufficient CPU/GPU resources"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Solutions"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Profile simulation"}),": Use ",(0,t.jsx)(s.code,{children:"gz sim --verbose"})," to identify bottlenecks"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Simplify collision geometries"}),": Replace complex meshes with primitive shapes (boxes, cylinders, spheres)"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Disable GUI"}),": Run headless (",(0,t.jsx)(s.code,{children:"gz sim -s"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Upgrade hardware"}),": Use a dedicated GPU and multi-core CPU"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"example-simulation-testing-script",children:"Example: Simulation Testing Script"}),"\n",(0,t.jsx)(s.p,{children:"Here's a complete Python script for automated simulation testing:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""\nAutomated navigation test in Gazebo simulation.\nTests robot\'s ability to navigate from start to goal without collisions.\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped, Twist\nfrom nav_msgs.msg import Odometry\nimport math\nimport time\n\nclass NavigationTestNode(Node):\n    def __init__(self):\n        super().__init__(\'navigation_test_node\')\n\n        # Publishers and subscribers\n        self.goal_pub = self.create_publisher(PoseStamped, \'/goal_pose\', 10)\n        self.cmd_vel_sub = self.create_subscription(Twist, \'/cmd_vel\', self.cmd_vel_callback, 10)\n        self.odom_sub = self.create_subscription(Odometry, \'/odom\', self.odom_callback, 10)\n\n        # Test parameters\n        self.goal = (5.0, 5.0)  # Target position (x, y)\n        self.tolerance = 0.3    # Goal reached tolerance (meters)\n        self.timeout = 60.0     # Test timeout (seconds)\n        self.max_linear_vel = 0.5  # Safety limit\n\n        # State\n        self.current_pose = None\n        self.test_start_time = None\n        self.collision_count = 0\n\n        self.get_logger().info("Navigation test node started")\n\n    def cmd_vel_callback(self, msg):\n        # Check velocity safety limits\n        if abs(msg.linear.x) > self.max_linear_vel:\n            self.get_logger().warn(f"Velocity exceeds safety limit: {msg.linear.x}")\n            self.collision_count += 1\n\n    def odom_callback(self, msg):\n        self.current_pose = msg.pose.pose\n\n    def run_test(self):\n        self.get_logger().info("Starting navigation test...")\n        self.test_start_time = time.time()\n\n        # Publish goal\n        goal_msg = PoseStamped()\n        goal_msg.header.frame_id = "map"\n        goal_msg.pose.position.x = self.goal[0]\n        goal_msg.pose.position.y = self.goal[1]\n        goal_msg.pose.orientation.w = 1.0\n        self.goal_pub.publish(goal_msg)\n\n        # Wait for goal to be reached or timeout\n        while rclpy.ok():\n            if self.current_pose is None:\n                self.get_logger().warn("Waiting for odometry...")\n                time.sleep(0.1)\n                continue\n\n            # Calculate distance to goal\n            dx = self.goal[0] - self.current_pose.position.x\n            dy = self.goal[1] - self.current_pose.position.y\n            distance = math.sqrt(dx**2 + dy**2)\n\n            # Check success condition\n            if distance < self.tolerance:\n                elapsed = time.time() - self.test_start_time\n                self.get_logger().info(f"\u2705 SUCCESS: Goal reached in {elapsed:.1f}s")\n                return True\n\n            # Check timeout condition\n            if time.time() - self.test_start_time > self.timeout:\n                self.get_logger().error(f"\u274c FAILURE: Timeout after {self.timeout}s (distance: {distance:.2f}m)")\n                return False\n\n            time.sleep(0.1)\n\n        return False\n\ndef main():\n    rclpy.init()\n    test_node = NavigationTestNode()\n\n    # Give simulation time to stabilize\n    time.sleep(2.0)\n\n    # Run test\n    success = test_node.run_test()\n\n    # Cleanup\n    test_node.destroy_node()\n    rclpy.shutdown()\n\n    exit(0 if success else 1)\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Usage"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-bash",children:"# Terminal 1: Launch Gazebo with robot\nros2 launch my_robot_pkg simulation.launch.py\n\n# Terminal 2: Run navigation stack\nros2 launch my_robot_pkg navigation.launch.py\n\n# Terminal 3: Run automated test\npython3 navigation_test.py\n"})}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Expected Output"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"[INFO] [navigation_test_node]: Navigation test node started\n[INFO] [navigation_test_node]: Starting navigation test...\n[INFO] [navigation_test_node]: \u2705 SUCCESS: Goal reached in 23.4s\n"})}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"hands-on-exercises",children:"Hands-On Exercises"}),"\n",(0,t.jsx)(s.h3,{id:"exercise-1-write-a-simulation-unit-test",children:"Exercise 1: Write a Simulation Unit Test"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Goal"}),": Create a unit test for a simple robot behavior."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Instructions"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"Choose a simple algorithm from your ROS 2 package (e.g., PID controller, path smoother)"}),"\n",(0,t.jsxs)(s.li,{children:["Write a Python ",(0,t.jsx)(s.code,{children:"unittest"})," test case with at least 3 test methods"]}),"\n",(0,t.jsxs)(s.li,{children:["Run the test with ",(0,t.jsx)(s.code,{children:"python3 -m unittest test_file.py"})]}),"\n",(0,t.jsx)(s.li,{children:"Ensure all tests pass"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Expected Outcome"}),": You have a passing unit test that validates algorithm behavior in isolation."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"exercise-2-optimize-physics-performance",children:"Exercise 2: Optimize Physics Performance"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Goal"}),": Improve simulation real-time factor by tuning physics parameters."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Instructions"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"Launch Gazebo with a complex robot model (multiple joints, sensors)"}),"\n",(0,t.jsx)(s.li,{children:"Record the current Real-Time Factor (RTF) displayed in Gazebo GUI"}),"\n",(0,t.jsxs)(s.li,{children:["Modify your world file to increase ",(0,t.jsx)(s.code,{children:"max_step_size"})," from ",(0,t.jsx)(s.code,{children:"0.001"})," to ",(0,t.jsx)(s.code,{children:"0.005"})]}),"\n",(0,t.jsx)(s.li,{children:"Relaunch Gazebo and compare RTF"}),"\n",(0,t.jsx)(s.li,{children:"Verify robot still behaves stably (no vibrations or instability)"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Expected Outcome"}),": RTF improves (e.g., from 0.6 to 0.9) without sacrificing physics stability."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"exercise-3-debug-collision-issues",children:"Exercise 3: Debug Collision Issues"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Goal"}),": Diagnose and fix physics instability in a robot model."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Instructions"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsx)(s.li,{children:"Create a simple URDF robot with a chassis and wheels"}),"\n",(0,t.jsx)(s.li,{children:"Intentionally create a collision overlap (wheel mesh intersects chassis)"}),"\n",(0,t.jsx)(s.li,{children:"Launch in Gazebo and observe the instability (shaking, incorrect behavior)"}),"\n",(0,t.jsx)(s.li,{children:"Enable collision visualization (View \u2192 Collisions in Gazebo)"}),"\n",(0,t.jsx)(s.li,{children:"Fix the URDF by adjusting collision geometry origins or sizes"}),"\n",(0,t.jsx)(s.li,{children:"Verify the robot is now stable"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Expected Outcome"}),": Robot model is stable with no overlapping collisions."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"exercise-4-measure-performance-metrics",children:"Exercise 4: Measure Performance Metrics"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Goal"}),": Collect quantitative data from simulation tests."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Instructions"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Use the ",(0,t.jsx)(s.code,{children:"navigation_test.py"})," script provided above"]}),"\n",(0,t.jsx)(s.li,{children:"Run the test 10 times with different goal positions"}),"\n",(0,t.jsxs)(s.li,{children:["Record metrics for each run:","\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Time to goal (seconds)"}),"\n",(0,t.jsx)(s.li,{children:"Maximum linear velocity (m/s)"}),"\n",(0,t.jsx)(s.li,{children:"Final distance error (meters)"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.li,{children:"Calculate statistics (mean, std deviation, success rate)"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Expected Outcome"}),": You have quantitative baseline metrics for your navigation system."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"exercise-5-validate-sensor-data",children:"Exercise 5: Validate Sensor Data"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Goal"}),": Compare simulated sensor data to real sensor specifications."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Instructions"}),":"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Add noise to a camera sensor in Gazebo (use Gaussian noise with ",(0,t.jsx)(s.code,{children:"stddev=0.01"}),")"]}),"\n",(0,t.jsx)(s.li,{children:"Publish camera images to a ROS 2 topic"}),"\n",(0,t.jsxs)(s.li,{children:["Use ",(0,t.jsx)(s.code,{children:"ros2 topic echo /camera/image_raw"})," to inspect image messages"]}),"\n",(0,t.jsx)(s.li,{children:"Compare simulated noise to real camera datasheet specifications"}),"\n",(0,t.jsx)(s.li,{children:"Adjust noise parameters to match real sensor"}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Expected Outcome"}),": Simulated camera has realistic noise characteristics matching real hardware."]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsx)(s.p,{children:"After completing this chapter, you should understand:"}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Testing Pyramid"}),": Progress from fast unit tests \u2192 integration tests \u2192 simulation tests \u2192 real robot tests to build confidence incrementally."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Sim-to-Real Gap"}),": Simulation is not perfect; always validate on real hardware and iterate on simulation parameters to improve realism."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Simulator Selection"}),": Choose Gazebo for physics testing, Unity for visualization/VR, and Isaac Sim for RL training based on project needs."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Performance Optimization"}),": Tune physics timesteps, reduce rendering overhead, run headless simulations, and use parallel instances to speed up testing."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Troubleshooting Skills"}),": Diagnose physics instability (check collisions, inertia, damping), sensor issues (add noise), and ROS 2 bridge failures (verify topic mappings)."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Automated Testing"}),": Write Python scripts to automate simulation tests, measure performance metrics, and enable continuous integration for robotic systems."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Hybrid Workflows"}),": Many teams use multiple simulators (Gazebo for physics, Unity for demos, Isaac for RL) to leverage each tool's strengths."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h2,{id:"navigation",children:"Navigation"}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Previous Chapter"}),": ",(0,t.jsx)(s.a,{href:"/docs/module-2-gazebo/unity-robotics",children:"Unity for Robotics"}),"\n",(0,t.jsx)(s.strong,{children:"Next Chapter"}),": ",(0,t.jsx)(s.a,{href:"/docs/module-3-isaac/intro-isaac",children:"Introduction to NVIDIA Isaac"})]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>l});var i=n(6540);const t={},r=i.createContext(t);function o(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);